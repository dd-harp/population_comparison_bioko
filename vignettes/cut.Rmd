---
title: "Cut from Comparison"
output: html_notebook
---

This notebook contains calculations that were offshoots of the main work.
It's here so that I can feely cut from a main vignette in order to use
it for presentation.

# Concern about Littoral Areas

I have an initial concern about population counts near
ocean borders. Different source datasets handle the land boundary differently,
both in how they demarcate it in the raster image and in how
the decide where land and sea meet. LandScan, for instance, errs in favor of
more land, so that they can include littoral populations in counts.
We can address this by enforcing each incoming dataset to mark sea
with the same NA value, and we can avoid questions about mismatches
by comparing the grid to the BIMEP GPS-driven data, set on the same
grid as the incoming raster. Land areas will still be a little different,
but I won't have to worry about population counts off the edge.


If you have an account at IHME, the following will copy files to
your local drive, under the data directory. Look at the
help for `data_configuration` to see about creating a config file
for the download.
```{r download, results = "hide"}
#download_worldpop(local_directory = data_dir)
#download_bioko_grids(local_directory = data_dir)
#download_hrsl_points(local_directory = data_dir)
```

# Discussion

Using estimation to find the urban area matters for the 100m data but not the 1km data.

I'm surprised at how much the BIMEP 100m numbers depend on which 100m grid is used. For instance, the BIMEP on HRSL has a higher empty percent than the others. I could understand this by regridding BIMEP data to a set of evenly-spaced grids.

The implied year for HRSL is the last census, which is older. The total populations are different enough, that maybe I should use a growth rate for correction.

The empty percent was very sensitive to my choice of lower bound for empty. Should I make a graph of how different datasets get close to zero? It's a problem for both WorldPop and LandScan. Let's go with 1 person in an area. It gets rid of clearly spurious nonzeros.

WorldPop provides an unscaled and a scaled version. We're using the scaled version. The unscaled looks a little cleaner, but the population is much too large. This seems like the choice that will lead to better numbers for WP.

The 1km data behaves like a smooth grid. The 100m and 30m data behave like points. I see that b/c the point smoothing makes a big difference on the urban numbers. At what resolution do we treat this data as point data?

Using a kernel density estimator gives the largest estimate for urban. The 1 km^2 disc seems to give the smallest.


# LS plot

The LandScan plot doesn't look right, so let's take a closer look before including it with the rest.

```{r test_landscan_plot}
map_idx <- 3
landscan_closeup <- raster::crop(bmaps[map_idx][[1]], bcrop)
raster::res(landscan_closeup)[[1]]
prod(raster::res(landscan_closeup))
raster::plot(landscan_closeup, colNA="black")
raster::hist(landscan_closeup)
vv <- raster::getValues(landscan_closeup)
c(min(vv, na.rm = TRUE), max(vv, na.rm = TRUE))
vv
tm_shape(landscan_closeup + 0.1) +
  tmap_options(max.categories = 1936) +
  tm_raster(colorNA = "black") +
  tm_layout(frame = TRUE)
```


```{r unused_maps}
bp1 <- tm_shape(bcropped) +
  tm_raster(title = "BIMEP", palette = bpal, breaks = bbreaks, labels = bnames) +
  tm_legend(show = FALSE) +
  tm_layout(title = "A", frame = FALSE)
bp2 <- tm_shape(raster::crop(bmaps[2][[1]], bcrop)) +
  tm_raster(title = "WorldPop", palette = bpal, breaks = bbreaks, labels = bnames) +
  tm_legend(show = FALSE) +
  tm_layout(title = "B", frame = FALSE)
bp3 <- tm_shape(raster::crop(bmaps[3][[1]], bcrop)) +
  tm_raster(title = "HRSL", palette = bpal, breaks = bbreaks, labels = bnames) +
  tm_legend(show = FALSE) +
  tm_layout(title = "C", frame = FALSE)
```


# From pfpr by population


```{r}
cdfAreaLines <- function(H, source, resolution, linewidth = 2) {
  H <- sort(H)
  area <-  c(1:length(H)) / length(H)
  lines(
    area,
    cumsum(H) / sum(H),
    col = colors[source],
    lwd = linewidth,
    lty = ifelse(resolution == "coarse", 1, 2)
    )
}

cdfAreaFigure <- function(llwd = 1, label = "") {
  plot(
    vector(mode = "numeric", length = 0),
    xlim = c(0, 1), ylim = c(0, 1),
    xlab =  "% Area", ylab =  "Proportion of Population",
    main = label
    )
  sources <- c("BIMEP", "HRSL", "LandScan", "WorldPop-C", "WorldPop-U", "GPW")
  for (source in sources) {
    for (resolution in c("coarse", "fine")) {
      if (source == "BIMEP") {
        data <- linear_from_source_resolution("HRSL", resolution, density)$x
      } else {
        data <- linear_from_source_resolution(source, resolution, density)$y
      }
      cdfAreaLines(data, source, resolution, linewidth = llwd)
    }
  }
  legend("topleft", legend =  sources, col = colors[sources],
         lty = 1, lwd = 2, cex = 1)
}

#cdfAreaFigure(2)
```


Loading data


```{r}
# Get the pfpr data.
source_data <- "/home/adolgert/dev/popbioko/inst/extdata/source"
load(file.path(source_data, "popData_image.RData"))
load(file.path(source_data, "pfpr_pops.RData"))
popk2 <- distinct(popk, popk$areaId, .keep_all = T)
poppr <- merge(mcprk, popk2, by = "areaId", all.x = T)
poppr <- poppr[!is.na(poppr$pop1k), ]

PfPR <- poppr$pfpr

H0 <- poppr$pop1k / sum(poppr$pop1k, na.rm = T)
H1 <- poppr$wppop / sum(poppr$wppop, na.rm = T)
H2 <- poppr$lspop / sum(poppr$lspop, na.rm = T)
H3 <- poppr$popfb / sum(poppr$popfb, na.rm = T)
```
