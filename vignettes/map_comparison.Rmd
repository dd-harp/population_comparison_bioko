---
title: "Comparing Population Maps"
author: "David L Smith, Carlos Guerra, Andrew Dolgert, Brendan Fries"
output:
  pdf_document:
    number_sections: true
    df_print: kable
    toc: true
header-includes:
  - \usepackage{palatino}
# The params block means you can put the data anywhere you like and
# then render this document by passing a parameter to the rmarkdown render command.
params:
  data_directory: !r fs::path(rprojroot::find_root(rprojroot::is_rstudio_project), "inst", "extdata")
---
From `r system("git config --get remote.origin.url", intern = TRUE)`
on `r date()`, generated by `r Sys.info()[["effective_user"]]`.

# Overview

This notebook calculates metrics from a population density map
by comparing them with a gold standard map.

```{r load_libraries, include = FALSE}
library(dplyr)
library(maptools)
library(plotrix)
library(sf)
library(sp)
library(spatstat)
library(viridis)

library(popbioko)
```


# Maps

The maps were made by the "get-data" vignette. We load them all
at once here for convenience. The naming scheme is dataset-on-grid,
where grids are 100m or 1km, according to where they come from.


```{r load_maps}
data_dir <- params$data_directory
map_root <- fs::path(data_dir, "aligned")
files <- list.files(map_root, pattern = "*.tif$")
files_df <- filenames_to_description(files)
maps <- lapply(files, function(x) raster::raster(fs::path(map_root, x)))
names(maps) <- rownames(files_df)
files_df
```
There are 12 rows for (3 data sources) x (2 resolutions each) x (data source and BIMEP comparison).

We will need some canonical projections, too. Universal Transverse Mercator (UTM)
is a projection that will give us the island measured in meters.
```{r canonical_projections}
utm_projection <- "+proj=utm +zone=32N +ellps=WGS84  +no_defs +units=m +datum=WGS84"
bioko_sf <- sf::st_read(fs::path(data_dir, "source", "bioko.shp"))
```


# Summary Statistics

The first figure is summary statistics, done at the pixel level.

## Urban Fraction

How should we calculate urban fraction? There isn't a single,
standard definition. Countries each choose their own ways to assess
the important demographic movement from rural to urban. These assessments
often combine population density, administrative boundaries,
resource availability (like sewer and water), and functional use patterns.
We have one kind of data here, population density, and we're interested
in how this data contributes to more nuanced urban metrics, but
let's stick to density.

Equatorial Guinea defines urban population density as 1500 people
per square kilometer. That's 1500 people per pixel for a grid
with 1 km pixels and 15 people per pixel for a grid with 100 m pixels.
This is equivalent to `r 1500 / (10^3)^2` people per meter squared.

We know we want to measure population density, but there are three ways
to measure population density.

1. Count each pixel that reaches the threshold.
2. Count each pixel that has 1500 people within a circle
   whose area is a square kilometer.
3. Use a kernel density estimator to treat pixels as
   samples from a population density surface.

### Raw Urban Fraction

We measure pixel threshold as a number of people per square
meter. We need to know the size of each pixel in order to do that.
It helps to know how many pixels we're talking about, so we return
the numerator and denominator of each fraction.
```{r urban_fraction_raw, code = capture.output(dump("urban_fraction", ""))}
```
We can reuse this function for the kernel density estimation
by applying it to the estimated density instead of the
raw density.

### Kernel Density Estimation

Kernel density estimation is a way to determine density from
a point set. We have a grid, not points, so we take a few
steps.

1. Convert the grid into a rate per unit area.
2. Sample points from that grid using a poisson process
   for each cell.
3. Project the points into a plane measured in meters.
4. Estimate percent urban from the resulting points.

This work will use the `raster` and `spatstat` packages
for statistics, and it will use the `proj4` package
to project the points from latitude-longitude to UTM.

```{r baseline_expectations_pop}
pop_raster <- maps[["LandScan on LandScan 1km"]]
sum(raster::values(pop_raster) > 1500, na.rm = TRUE) / nrow(pop_raster) / ncol(pop_raster)
```

```{r estimator, code = capture.output(dump("population_count_estimator", ""))}
```


```{r convert_grid_into_rate_per_unit_area, code = capture.output(dump("urban_fraction_by_point_density", ""))}
```

It will help to use the Bioko outlines for windowing
in spatstat. You need to translate sf to sp to sp geometry
to spatstat owin.
```{r bioko_spatsat}
bioko_sp <- as(bioko_sf, Class = "Spatial")
bioko_sp_polygon <- as(bioko_sp, "SpatialPolygons")
# Cannot make an owin from an unprojected space. Apparently.
bioko_proj_sf <- sf::st_transform(bioko_sf, crs = utm_projection)
# The projected space will have points outside. Let's make a little
# buffer to catch those points.
meters <- 1
bioko_buffer_sf <- sf::st_buffer(bioko_proj_sf, 500 * meters)
bioko_proj_sp <- as(bioko_proj_sf, Class = "Spatial")
bioko_proj_polygon_sp <- as(bioko_proj_sp, "SpatialPolygons")
bioko_owin <- as.owin(bioko_proj_polygon_sp)
```


```{r compute_density, eval = FALSE}
pop_raster <- maps[["LandScan on LandScan 1km"]]
ls1km_density <- urban_fraction_by_point_density(pop_raster, utm_projection, 1500)
ls1km_density
```


Landscan measures people in thousands, so urban is pixels
above `r 1500 / (10^3)^2 / 1000`. The population density is
on a map in meters, so let's count the pixel size in square meters.

Let's make population maps for every incoming map.
This step approximates the map values by projecting them from lat-long
to UTM coordinates. It uses bilinear interpolation. We avoid this kind
of approximation through most of our work. This step is less sensitive
to interpolation because it will construct point process models during
the `population_count_estimator`.
```{r make_population_maps}
raster_dir <- fs::path(params$data_directory, "density_raster")
if (!dir.exists(raster_dir)) {
  dir.create(raster_dir)
}
for (map_idx in 1:nrow(files_df)) {
  filename <- fs::path(raster_dir, files_df[map_idx, "filename"])
  if (!file.exists(filename)) {
    proj_raster <- raster::projectRaster(maps[[map_idx]], crs = utm_projection)
    # Projection uses bilinear interpolation, which can cause negative values.
    proj_raster <- raster::clamp(proj_raster, lower = 0)
    pop_density_im <- population_count_estimator(proj_raster)
    pop_density_raster <- im_to_raster(pop_density_im, utm_projection)
    raster::writeRaster(pop_density_raster, filename = filename, format = "GTiff")
  }
}
```

The density maps are saved as GeoTIFFs in the `density_raster` subdirectory,
so load them here before making the summary table.
```{r load_densities}
density <- lapply(files_df$filename, function(x) raster::raster(fs::path(raster_dir, x)))
names(density) <- names(maps)
```

## Construct the Summary Statistics Table
This function makes the first table in the paper.
It makes data for two urban densities, 1000 people per square km
and 1500 people per square km. We use the former to compare
with the current numbers, but the latter is what Equatorial
Guinea uses to define urban.
```{r summary_statistics}
summary_help <- function(urban_cutoff) {
  function(map_idx) {
    popbioko::summary_statistics(
      maps[[map_idx]], density[[map_idx]], urban_per_kilometer_sq = urban_cutoff
      )
  }
}


make_summary_df <- function(urban_cutoff) {
  summary_stats <- lapply(1:length(maps), summary_help(urban_cutoff))
  summary_list <- do.call(rbind, summary_stats)
  rownames(summary_list) <- names(maps)
  summary_df <- as.data.frame(summary_list)
  summary_df["name"] <- rownames(summary_list)
  summary_df <- merge(summary_df, files_df, by = "name")
}
summary1000_df <- make_summary_df(1000)
summary1500_df <- make_summary_df(1500)
names(summary1500_df)
```

Those dataframes are both strings and numeric. When we rotate them,
they will be all strings, so let's do the conversion by hand.
```{r hrsl_only_shown}
for_show <- function(summary_df) {
  urban_raw_percent <- as.numeric(summary_df[, "urban_raw"]) * 100
  urban_percent <- as.numeric(summary_df[, "urban_fit"]) * 100
  data.frame(
    source = summary_df$source,
    grid = summary_df$grid,
    resolution = as.character(summary_df$resolution),
    total = sprintf("%.0f", summary_df$total),
    maximum = sprintf("%.0f", summary_df$maximum),
    empty_percent = sprintf("%.4g", summary_df$empty_percent),
    na_percent = sprintf("%.4g", summary_df$na_percent),
    urban_raw = sprintf("%.4g", urban_raw_percent),
    urban_fit = sprintf("%.4g", urban_percent),
    pareto_fraction = sprintf("%.4g", 100 * as.numeric(summary_df$pareto_fraction))
  )
}
show1000_df <- for_show(summary1000_df)
show1500_df <- for_show(summary1500_df)
```
## Comparison Tables

### Compare two urban fractions
We're looking for trends that show there are fewer urban areas
when we raise the urban criteria from 1000 people to 1500 people per square
kilometer.
```{r compare_the_two}
as.data.frame(t(show1000_df[show1000_df$grid == "HRSL", ]))
```


```{r}
as.data.frame(t(show1500_df[show1500_df$grid == "HRSL", ]))
```

### Compare maps of raw and estimated urban fractions
We would like to see whether the estimated urban fraction has
a reasonable-looking gaussian kernel size.
```{r why_the_same}
sq_m_per <- c(square_meters_per_pixel.raster(maps[[2]]), square_meters_per_pixel.raster(density[[2]]))
sq_m_per
```
```{r cutoff_for_each}
cutoffs <- data.frame(urban_per_meter_sq = c(1000, 1500) / 10^6)
cutoffs["raw"] <- cutoffs[["urban_per_meter_sq"]] * square_meters_per_pixel.raster(maps[[2]])
cutoffs["density"] <- cutoffs[["urban_per_meter_sq"]] * square_meters_per_pixel.raster(density[[2]])
cutoffs
```
Plot these with cutoffs to see that the maps are similar.
```{r make_sure_maps_similar}
plot(maps[[2]] / cutoffs[1, "raw"])
plot(maps[[2]] / cutoffs[2, "raw"])
plot(density[[2]] / cutoffs[1, "density"])
plot(density[[2]] / cutoffs[2, "density"])
```

### Compare across source grids
This shows all HRSL grid together, then all WorldPop, then all LandScan.
```{r}
as.data.frame(t(show1500_df[show1500_df$grid == "HRSL", ]))
```

```{r}
as.data.frame(t(show1500_df[show1500_df$grid == "WorldPop", ]))
```

```{r}
as.data.frame(t(show1500_df[show1500_df$grid == "LandScan", ]))
```

### Compare across resolutions
This groups data with the same resolution.
```{r}
as.data.frame(t(show1500_df[show1500_df$resolution == 100, ]))
```

```{r}
as.data.frame(t(show1500_df[show1500_df$resolution == 1000, ]))
```

## Discussion

- Using estimation to find the urban area matters for the 100m
  data but not the 1km data.
- I'm surprised at how much the BIMEP 100m numbers depend on
  which 100m grid is used. For instance, the BIMEP on HRSL has a higher empty
  percent than the others. I could understand this by regridding
  BIMEP data to a set of evenly-spaced grids.
- I don't know the implied year for HRSL here. The total populations
  are different enough, that maybe I should use a growth rate
  for correction.
- The empty percent was very sensitive to my choice of lower
  bound for empty. Should I make a graph of how different
  datasets get close to zero? It's a problem for both WorldPop
  and LandScan.


# Population Scatter Plots

This section makes figure 4, scatter plots of population data versus ground truth
population data. The density plots use maps of either resolution to plot
estimated density per square km. The population size plots instead
use the count of people in a pixel.

Set up consistent colors for the different data sets.
```{r set_colors, echo=FALSE}
colors <- c(viridis::plasma(8, alpha = 1, begin = 0, end = 1)[c(1, 3, 5, 7)], grey(0.7))
names(colors) <- c("BIMEP", "WorldPop", "LandScan", "HRSL", "grey")

logarithmic_axis_labels <- c(
  "1", "10", "100", "1,000", expression(10^4), expression(10^5), expression(10^6))
```

```{r log_offset_for_plot}
log_offset <- function(offset) {
  function(x) {
    log(x + offset)
  }
}
```

```{r plot_all_together}
logoff <- log_offset(1)
symbol_size <- c(0.5, 0.25)
names(symbol_size) <- c("1000", "100")
symbol_choice <- c(19, 15)
names(symbol_choice) <- c("1000", "100")


map_from_source_resolution <- function(source, resolution, map_list) {
  xy_df <- files_df[files_df$resolution == resolution & files_df$grid == source, ]
  x_map_name <- xy_df[xy_df$source == "BIMEP", "name"]
  y_map_name <- xy_df[xy_df$source == source, "name"]
  x <- raster::getValues(map_list[[x_map_name]])
  y <- raster::getValues(map_list[[y_map_name]])
  list(x = logoff(x), y = logoff(y))
}


#' This gets population counts, not density.
xy_from_source_resolution <- function(source, resolution) {
  map_from_source_resolution(source, resolution, maps)
}
  

density_from_source_resolution <- function(source, resolution) {
  map_from_source_resolution(source, resolution, density)
}


pop_scatter <- function(y_name, resolution, labels, title, maximum, background = NULL) {
  for (plot_idx in 1:length(y_name)) {
    y_source <- y_name[plot_idx]
    y_resolution <- resolution[plot_idx]
    xy <- xy_from_source_resolution(y_source, y_resolution)
    cex <- symbol_size[as.character(y_resolution)]
    pch <- symbol_choice[as.character(y_resolution)]
    color <- colors[y_source]
    if (!is.null(background) & plot_idx %in% background) {
      color <- colors["grey"]
    }
    if (plot_idx == 1) {
      plot(
        xy, col = color, cex = cex, pch = pch,
        xlim = c(0, maximum), ylim = c(0, maximum),
        xlab = labels[[1]], ylab = labels[[2]], main = title,
        xaxt = "n", yaxt = "n"
        )
      axis(1, logoff(10^c(0:5)), 10^c(0:5))
      axis(2, logoff(10^c(0:5)), 10^c(0:5))
      segments(logoff(0), logoff(0), logoff(10^5), logoff(10^5))
      segments(logoff(1), logoff(1), logoff(1), logoff(10^5), col = colors["grey"])
      segments(logoff(1), logoff(1), logoff(10^5), logoff(1), col = colors["grey"])

    } else {
      points(xy, col = color, cex = cex, pch = pch)
    }
  }
}
```

```{r all_together}
density_label <- c("BIMEP Population Density", "Mapped Population Density")
maximum1k <- 1.01 * max(xy_from_source_resolution("LandScan", 1000)$y, na.rm = TRUE)
the_three <- c("HRSL", "LandScan", "WorldPop")
pop_scatter(
  c(the_three, "HRSL", "WorldPop"), c(rep(1000, 3), rep(100, 2)),
  density_label, "A", maximum1k)
legend("topleft", legend =  the_three, col = colors[the_three],
           lty = 1, lwd = 2, cex = 1, bg = "white", bty = "n")
```

```{r plot_landscan_density}
pop_scatter(
  "LandScan", 1000,
  density_label, "B) LandScan", maximum1k)
```

```{r plot_hrsl_density}
pop_scatter(
  rep("HRSL", 2), c(100, 1000),
  density_label, "C) HRSL", maximum1k, background = 1)
```

```{r plot_woldpop_density}
pop_scatter(
  rep("WorldPop", 2), c(100, 1000),
  density_label, "D) WorldPop", maximum1k, background = 1)
```


```{r}
ff1 <- function(x,offset=0) {
  log(1 + x + offset)
  }

scatter1k.add <- function(yy, cid = 5, ff = ff1, offset = 0, cx = .7) {
  points(ff(popk$pop1k,offset), ff(yy,offset), col = col[cid], pch = 19, cex = cx) 
}

scatter1k <- function(
  yy, cid = 5, ff = ff1, offset = 0, cx = .7,
  lgn = FALSE, tl = "", xlb = "BIMEP Population Density"
  )
  {
  mx <- max(popk$lspop) * 1.01
  plot(ff(popk$pop1k,offset), ff(yy,offset), col = col[cid], pch = 19,
       xlim = ff(c(0,mx)), ylim = ff(c(0,mx)), xaxt = "n", yaxt = "n",
       xlab = xlb, ylab = "Mapped Population Density", cex = cx, main = tl)
  axis(1, ff(10^c(0:5)), 10^c(0:5))
  axis(2, ff(10^c(0:5)), 10^c(0:5))
  segments(ff(0), ff(0), ff(10^5), ff(10^5))
  segments(ff(1), ff(1), ff(1), ff(10^5), col = grey(0.7))
  segments(ff(1), ff(1), ff(10^5), ff(1), col = grey(0.7))
  scatter1k.add(yy,cid,ff,offset,cx)
  if (lgn) {
    legend("topleft", legend =  c("HRSL", "Landscan", "WorldPop"), col = col[c(7,5,3)],
           lty = 1, lwd = 2, cex = 1, bg = "white", bty = "n")
  }
}

scatter100m <- function(
  yy, gold = ddpop100, clr = gry, ff = ff1, offset = 0, cx = .7,
  lgn = FALSE, tl = "", xlb = "BIMEP Population Density", ylb = "Population Density"
  )
  {
  mx <- max(gold)*1.01
  plot(ff(gold,offset), ff(yy,offset), col = clr, pch = 15, xlim = ff(c(0,mx)),
       ylim = ff(c(0,mx)), xaxt = "n", yaxt = "n", xlab = xlb, ylab = ylb, cex = cx, main = tl)
  axis(1, ff(10^c(0:5)), 10^c(0:5))
  axis(2, ff(10^c(0:5)), 10^c(0:5))
  segments(ff(0), ff(0), ff(10^5), ff(10^5))
  segments(ff(1), ff(1), ff(1), ff(10^5), col = grey(0.7))
  segments(ff(1), ff(1), ff(10^5), ff(1), col = grey(0.7))

  scatter100m.add(yy,gold,clr,ff,offset,cx)
  if (lgn) {
    legend("topleft", legend =  c("HRSL", "Landscan", "WorldPop"), col = col[c(7,5,3)],
           lty = 1, lwd = 2, cex = 1, bg = "white", box.col = "white")
  }
}

scatter100m.add <- function(yy, gold = ddpop100, clr = gry, ff = ff1, offset = 0, cx = .7) {
  points(ff(gold,offset), ff(yy,offset), col = clr, pch = 15, cex = cx) 
}
```

```{r, fig.height=6, fig.width=6}
wpclr <- col[3]
gry <- grey(0.8)

scatter1kFigure <- function() {
  cxx <- .5
  par(mfrow = c(3,2), mar = c(5,4.2,3,2))
  scatter1k(popk$lspop, cx = cxx, lgn = TRUE, tl = "A")
  scatter1k.add(popk$popfb, cid = 7, cx = cxx)
  scatter1k.add(popk$wppop, cid = 3, cx = cxx)
  scatter100m.add(ddwppop, clr = wpclr, cx = cxx/2)
  scatter100m.add(ddpopfb, clr = fbclr, cx = cxx/2)
  scatter1k(popk$lspop,cx = cxx, tl = "B) Landscan")
  scatter1k(popk$popfb, cid = 7,cx = cxx, tl = "C) HRSL", lgn=FALSE)
  scatter100m.add(ddpopfb, clr = gry, cx = cxx/2)
  scatter1k.add(popk$popfb, cid = 7,cx = cxx)
  scatter1k(popk$wppop, cid = 3,cx = cxx, tl = "D) WorldPOP")
  scatter100m.add(ddwppop, clr = gry, cx = cxx/2)
  scatter1k.add(popk$wppop, cid = 3, cx = cxx)
  scatter100m(popm$popfb, gold=popm$pop100,
              xlb = "BIMEP 100x100 m", ylb = "Population Size",
              clr = fbclr,cx = cxx/2, tl = "E) HRSL, 100x100 m")
  scatter100m(popm$wppop, gold = popm$pop100,
              xlb = "BIMEP 100x100 m", ylb = "Population Size",
              clr = wpclr, cx = cxx/2, tl = "F) WP, 100x100 m")
}


scatter1kFigure() 

#points(ff(popk$pop1k), ff(popk$popfb), col = col[7], pch = 15)
#points(ff(popk$pop1k), ff(popk$wppop), col = col[3], pch = 17)

```
