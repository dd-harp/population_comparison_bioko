---
title: "Comparing Population Maps"
author: "David L Smith, Carlos Guerra, Andrew Dolgert, Brendan Fries"
output:
  pdf_document:
    number_sections: true
    df_print: kable
header-includes:
  - \usepackage{palatino}
# The params block means you can put the data anywhere you like and
# then render this document by passing a parameter to the rmarkdown render command.
params:
  data_directory: !r fs::path(rprojroot::find_root(rprojroot::is_rstudio_project), "inst", "extdata")
---
From `r system("git config --get remote.origin.url", intern = TRUE)`
on `r date()`, generated by `r Sys.info()[["effective_user"]]`.

# Overview

This notebook calculates metrics from a population density map
by comparing them with a gold standard map.

```{r load_libraries, include = FALSE}
library(popbioko)
```


# Maps

The maps were made by the "get-data" vignette. We load them all
at once here for convenience. The naming scheme is dataset-on-grid,
where grids are 100m or 1km, according to where they come from.


```{r load_maps}
data_dir <- params$data_directory
map_root <- fs::path(data_dir, "aligned")
files <- list.files(map_root, pattern = "*.tif$")
files_df <- filenames_to_description(files)
maps <- lapply(files, function(x) raster::raster(fs::path(map_root, x)))
names(maps) <- rownames(files_df)
files_df
```
There are 12 rows for (3 data sources) x (2 resolutions each) x (data source and BIMEP comparison).

We will need some canonical projections, too.
UTM is a projection that will give us the island measured in meters.
```{r canonical_projections}
utm_projection <- "+proj=utm +zone=32N +ellps=WGS84  +no_defs +units=m +datum=WGS84"
```


# Summary Statistics

The first figure is summary statistics, done at the pixel level.

## Urban Fraction

How should we calculate urban fraction? There isn't a single,
standard definition. Countries each choose their own ways to assess
the important demographic movement from rural to urban. These assessments
often combine population density, administrative boundaries,
resource availability (like sewer and water), and functional use patterns.
We have one kind of data here, population density, and we're interested
in how this data contributes to more nuanced urban metrics, but
let's stick to density.

Equatorial Guinea defines urban population density as 1500 people
per square kilometer. That's 1500 people per pixel for a grid
with 1 km pixels and 15 people per pixel for a grid with 100 m pixels.
This is equivalent to `r 1500 / (10^3)^2` people per meter squared.

We know we want to measure population density, but there are three ways
to measure population density.

1. Count each pixel that reaches the threshold.
2. Count each pixel that has 1500 people within a circle
   whose area is a square kilometer.
3. Use a kernel density estimator to treat pixels as
   samples from a population density surface.

In order to try a kernel density estimator, we should use a consistent bandwidth,
so let's get that using a standard bandwidth estimator on the
golden data. We have to calculate that bandwidth in projection
because the kernel density estimator only works in projection.

```{r}
landscan1km_landscan <- maps[["LandScan on LandScan 1km"]]
raster_to_im <- function(raster_image) {
  numeric_matrix <- raster::as.matrix(raster_image)
  xrange <- c(raster::xmin(raster_image), raster::xmax(raster_image))
  yrange <- c(raster::ymin(raster_image), raster::ymax(raster_image))
  # spatstat::im(numeric_matrix[nrow(numeric_matrix):1, ], xrange = xrange, yrange = yrange)
  x <- raster::xFromCol(raster_image, 1:raster::ncol(raster_image))
  y <- raster::yFromRow(raster_image, 1:raster::nrow(raster_image))
  spatstat::im(numeric_matrix[nrow(numeric_matrix):1, ], xcol = x, yrow = y)
}
raster_sum <- raster::cellStats(landscan1km_landscan, stat = "sum", na.rm = TRUE)
ls1km_ls_im <- maptools::as.im.RasterLayer(landscan1km_landscan)
point_pattern <- spatstat::rpoispp(ls1km_ls_im, nsim = 1)

# Notice if we're off by a factor of 10.
# That means we're not setting raster pixels as a rate per unit area.
stopifnot(point_pattern$n > 0.5 * raster_sum)
stopifnot(point_pattern$n < 1.5 * raster_sum)

project_points <- function(points, projection) {
  xy <- proj4::project(list(points$x, points$y), projection)
  xrange <- c(min(xy$x), max(xy$x))
  spatstat::ppp(xy[["x"]], xy[["y"]], window = spatstat::owin(xrange = xrange, yrange = c(min(xy$y), max(xy$y))))
}
projected <- project_points(point_pattern, utm_projection)
dens <- spatstat::density.ppp(projected)
```

Landscan measures people in thousands, so urban is pixels
above `r 1500 / (10^3)^2 / 1000`


```{r calculate_bandwidth}
point_bandwidth <- function() {
  pop_gps <- read_bimep_point_data(local_directory = data_dir)
  pop_projected <- sf::st_transform(
    pop_gps,
    crs = "+proj=utm +zone=32N +ellps=WGS84  +no_defs +units=m +datum=WGS84"
    )
  coordinates <- sf::st_coordinates(pop_projected)
  lon_bw <- power_bandwidth(coordinates[, "X"])
  lat_bw <- power_bandwidth(coordinates[, "Y"])
  sqrt(lon_bw * lat_bw)
}
bandwidth <- point_bandwidth()
bandwidth
```
That number is really low. Probably only appropriate for the
point data. What's the number when we use the raster information?

```{r bandwidth_from_raster}
one_projected <- raster::projectRaster(maps$`BIMEP on HRSL1000`,
                                       crs = utm_projection)
power_bandwidth(raster::coordinates(one_projected)[, 1])
```


We also need an outline of Bioko in order to tell the kernel density
when it's at the edge of habitable space.
```{r load_bioko_outline}
bioko_sf <- sf::st_read(fs::path(data_dir, "source", "bioko.shp"))
```


```{r summary_statistics}
summary_help <- function(amap) {
  summary_statistics(amap, attr(amap, "resolution"), bioko_sf, bandwidth)
}
summary_stats <- lapply(maps, summary_help)
summary_df <- do.call(rbind, summary_stats)
rownames(summary_df) <- names(maps)
t(summary_df)
```

