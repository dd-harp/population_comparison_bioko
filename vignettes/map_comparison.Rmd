---
title: "Comparing Population Maps"
author: "David L Smith, Carlos Guerra, Andrew Dolgert, Brendan Fries"
output:
  pdf_document:
    number_sections: true
    df_print: kable
header-includes:
  - \usepackage{palatino}
# The params block means you can put the data anywhere you like and
# then render this document by passing a parameter to the rmarkdown render command.
params:
  data_directory: !r fs::path(rprojroot::find_root(rprojroot::is_rstudio_project), "inst", "extdata")
---
From `r system("git config --get remote.origin.url", intern = TRUE)`
on `r date()`, generated by `r Sys.info()[["effective_user"]]`.

# Overview

This notebook calculates metrics from a population density map
by comparing them with a gold standard map.

```{r load_libraries, include = FALSE}
library(maptools)
library(sf)
library(sp)
library(spatstat)
library(popbioko)
```


# Maps

The maps were made by the "get-data" vignette. We load them all
at once here for convenience. The naming scheme is dataset-on-grid,
where grids are 100m or 1km, according to where they come from.


```{r load_maps}
data_dir <- params$data_directory
map_root <- fs::path(data_dir, "aligned")
files <- list.files(map_root, pattern = "*.tif$")
files_df <- filenames_to_description(files)
maps <- lapply(files, function(x) raster::raster(fs::path(map_root, x)))
names(maps) <- rownames(files_df)
files_df
```
There are 12 rows for (3 data sources) x (2 resolutions each) x (data source and BIMEP comparison).

We will need some canonical projections, too. Universal Transverse Mercator (UTM)
is a projection that will give us the island measured in meters.
```{r canonical_projections}
utm_projection <- "+proj=utm +zone=32N +ellps=WGS84  +no_defs +units=m +datum=WGS84"
bioko_sf <- sf::st_read(fs::path(data_dir, "source", "bioko.shp"))
```


# Summary Statistics

The first figure is summary statistics, done at the pixel level.

## Urban Fraction

How should we calculate urban fraction? There isn't a single,
standard definition. Countries each choose their own ways to assess
the important demographic movement from rural to urban. These assessments
often combine population density, administrative boundaries,
resource availability (like sewer and water), and functional use patterns.
We have one kind of data here, population density, and we're interested
in how this data contributes to more nuanced urban metrics, but
let's stick to density.

Equatorial Guinea defines urban population density as 1500 people
per square kilometer. That's 1500 people per pixel for a grid
with 1 km pixels and 15 people per pixel for a grid with 100 m pixels.
This is equivalent to `r 1500 / (10^3)^2` people per meter squared.

We know we want to measure population density, but there are three ways
to measure population density.

1. Count each pixel that reaches the threshold.
2. Count each pixel that has 1500 people within a circle
   whose area is a square kilometer.
3. Use a kernel density estimator to treat pixels as
   samples from a population density surface.

### Kernel Density Estimation

Kernel density estimation is a way to determine density from
a point set. We have a grid, not points, so we take a few
steps.

1. Convert the grid into a rate per unit area.
2. Sample points from that grid using a poisson process
   for each cell.
3. Project the points into a plane measured in meters.
4. Estimate percent urban from the resulting points.

This work will use the `raster` and `spatstat` packages
for statistics, and it will use the `proj4` package
to project the points from latitude-longitude to UTM.

```{r baseline_expectations_pop}
pop_raster <- maps[["LandScan on LandScan 1km"]]
sum(raster::values(pop_raster) > 1500, na.rm = TRUE) / nrow(pop_raster) / ncol(pop_raster)
```

```{r estimator, code = capture.output(dump("population_density_estimator", ""))}
```


```{r convert_grid_into_rate_per_unit_area, code = capture.output(dump("urban_fraction_by_point_density", ""))}
pop_raster <- maps[["LandScan on LandScan 1km"]]
# We want the lat-long area, which isn't a distance but a solid angle.
pixel_width <- raster::xFromCol(pop_raster, ncol(pop_raster) / 2 + 1) -
  raster::xFromCol(pop_raster, ncol(pop_raster) / 2)
pixel_height <- raster::yFromRow(pop_raster, nrow(pop_raster) / 2 + 1) -
  raster::yFromRow(pop_raster, nrow(pop_raster) / 2)
latlong_pixel_area <- abs(pixel_width * pixel_height)
rate_raster <- pop_raster / latlong_pixel_area
```

It will help to use the Bioko outlines for windowing
in spatstat. You need to translate sf to sp to sp geometry
to spatstat owin.
```{r bioko_spatsat}
bioko_sp <- as(bioko_sf, Class = "Spatial")
bioko_sp_polygon <- as(bioko_sp, "SpatialPolygons")
# Cannot make an owin from an unprojected space. Apparently.
bioko_proj_sf <- sf::st_transform(bioko_sf, crs = utm_projection)
# The projected space will have points outside. Let's make a little
# buffer to catch those points.
meters <- 1
bioko_buffer_sf <- sf::st_buffer(bioko_proj_sf, 500 * meters)
bioko_proj_sp <- as(bioko_proj_sf, Class = "Spatial")
bioko_proj_polygon_sp <- as(bioko_proj_sp, "SpatialPolygons")
bioko_owin <- as.owin(bioko_proj_polygon_sp)
```


```{r compute_density, eval = FALSE}
pop_raster <- maps[["LandScan on LandScan 1km"]]
ls1km_density <- urban_fraction_by_point_density(pop_raster, utm_projection, 1500)
ls1km_density
```


Landscan measures people in thousands, so urban is pixels
above `r 1500 / (10^3)^2 / 1000`. The population density is
on a map in meters, so let's count the pixel size in square meters.



```{r summary_statistics}
summary_help <- function(map_idx) {
  amap <- maps[[map_idx]]
  resolution <- files_df$resolution[map_idx]
  popbioko::summary_statistics(amap, resolution, bioko_sf, utm_projection)
}
summary_stats <- lapply(1:length(maps), summary_help)
summary_list <- do.call(rbind, summary_stats)
rownames(summary_list) <- names(maps)
summary_df <- as.data.frame(summary_list)
summary_df["name"] <- rownames(summary_list)
summary_df <- merge(summary_df, files_df, by = "name")
```
```{r}
t(summary_df[summary_df$grid == "HRSL", ])
```

```{r}
t(summary_df[summary_df$grid == "WorldPop", ])
```

```{r}
t(summary_df[summary_df$grid == "LandScan", ])
```

```{r}
t(summary_df[summary_df$resolution == 100, ])
```

```{r}
t(summary_df[summary_df$resolution == 1000, ])
```
