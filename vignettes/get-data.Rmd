---
title: "Get Data"
output:
  pdf_document: default
  html_document:
    df_print: paged
cache: yes
---

```{r knitr_options, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(popbioko)
library(rprojroot)
library(sp)
library(sf)
library(tmap)
library(GISTools)
```

# Overview
This notebook retrieves input data and converts it into
gridded data about population density.

# Get Datasets
Specify a directory into which to put the data.
The `inst/extdata` subdirectory is a popular place.
```{r data_dir}
data_dir <- fs::path(rprojroot::find_root(rprojroot::is_rstudio_project), "inst", "extdata")
if (!dir.exists(data_dir)) {
  dir.create(data_dir, recursive = TRUE)
}
```
The data will be stored in `$r data_dir$`.

```{r predefinitions}
lat_long_proj <- "+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs"
```


If you have an account at IHME, the following will copy files to
your local drive, under the data directory. Look at the
help for `data_configuration` to see about creating a config file
for the download.
```{r download, results = "hide"}
download_worldpop(local_directory = data_dir)
download_bioko_grids(local_directory = data_dir)
download_hrsl_points(local_directory = data_dir)
```

# Align HRSL and BIMEP to BIMEP 1k Grid
The Bioko grids define cells where BIMEP assigns residents of
the island. One is a 1 km grid, the other a 100 m grid.
If we read those grids, we can see that the input files
are projected into UTM 32N, which makes all distances in meters.
That's very convenient, but the original grids were defined as
a regular grid in latitude and longitude.
```{r grids, dependson = c("data_dir", "download")}
grids <- read_bioko_grids(local_directory = data_dir)
grid_info <- parameters_of_km_grid(grids$coarse, unproject = TRUE)
```
You can see from the description above that the coarse
and fine grids are shapefiles. Are these grids complete, or are they partial?
```{r complete_grids}
area_per_pixel <- function(grid) {
  bbox <- st_bbox(grid)
  (bbox["xmax"] - bbox["xmin"]) * (bbox["ymax"] - bbox["ymin"])
}
cat("area per pixel coarse", area_per_pixel(grids$coarse) / 3894, "\n")
cat("area per pixel fine", area_per_pixel(grids$fine) / 197086, "\n")
```
We see that the area per pixel for the coarse is about $10^6\:\mbox{m}^2$, which
means it's probably a complete grid. The fine grid looks far from complete
because we expect $10^4\:\mbox{m}^2$ per pixel.

If we want to make such a grid, we could use
```{r grid_copy, dpeendson = c("download")}
coarse_grid_copy <- make_fresh_grid(grid_info$bbox, grid_info$dimensions)
```
We can show the original and copy in unprojected space
in order to see that they overlap.
```{r compare_1km_grids, fig.cap = "The original and our copy overlap.", dependson = "grid_copy"}
grid_1km <- sf::st_transform(grids$coarse, crs = lat_long_proj)
tm_shape(coarse_grid_copy) +
  tm_polygons(alpha = 0.1, border.col = "red") +
  tm_shape(grid_1km) +
  tm_polygons(alpha = 0.0, border.col = "blue")
```


What if we directly make a raster version of the 1km grid?
```{r make_raster}
km_raster <- raster::raster(
  ncol = grid_info$dimensions[1],
  nrow = grid_info$dimensions[2],
  xmn = grid_info$bbox["xmin"],
  xmx = grid_info$bbox["xmax"],
  ymn = grid_info$bbox["ymin"],
  ymx = grid_info$bbox["ymax"]
  )
raster::projection(km_raster) <- lat_long_proj
```

Let's get some points to project to that raster.
```{r hrsl_plot}
hrsl_raster <- read_hrsl(local_directory = data_dir)
hrsl_points_sf <- hrsl_points(hrsl_raster)
hrsl_points_sf[is.na(hrsl_points_sf[[1]]), 1] <- 0
```

And do the projection using a builtin function of the raster package.
```{r project_to_raster}
km_hrsl_raster <- raster::rasterize(
  hrsl_points_sf,
  km_raster,
  field = "population_gnq_2018.10.01",
  fun = sum
  )
```

```{r}
plot(km_hrsl_raster)
```

Now do the same thing for the BIMEP data. It will have a "pop"
feature for the population in the pixel.
```{r bimep_raster}
bimep_feature <- bimep_population_as_points(local_directory = data_dir)
names(bimep_feature)
```
Rasterize that pop feature, summing it per pixel.
```{r}
bimep_raster <- raster::rasterize(
  bimep_feature,
  km_raster,
  field = "pop",
  fun = sum
  )
names(bimep_raster)
```
```{r}
plot(bimep_raster)
```

Write these as layers to a GeoTIFF.
```{r write_hrsl_bimep}
names(km_hrsl_raster) <- c("HRSL")
names(bimep_raster) <- c("BIMEP")
both_layers <- raster::addLayer(km_hrsl_raster, bimep_raster)
raster::writeRaster(both_layers, filename = fs::path(data_dir, "hrsl_bimep"), format = "GTiff")
```


```{r, eval = FALSE}
grids$coarse["hrsl"] <- hrsl_points_sf[[1]]
tm_shape(grids$coarse[grids$coarse$hrsl > 0,]) +
  tm_polygons("hrsl", title = "HRSL", palette = "Greens", style = "log10") +
  tm_layout(legend.title.size = 1, legend.text.size = 1)
```

# Align BIMEP to LandScan Grid

The LandScan grid is an Arc/Info Binary Grid, so it's the adf type.
It uses pixel sizes of 0.008333 in both dimensions.
It's the whole world, so we will subset it.

```{r landscan}
landscan <- read_landscan(local_directory = data_dir)
landscan <- raster::crop(landscan, bimep_feature, snap = "out")
plot(landscan)
```
Now put the bimep 100m data on the LandScan raster.
```{r}
bimep_landscan_raster <- raster::rasterize(
  bimep_feature,
  landscan,
  field = "pop",
  fun = sum
  )
names(bimep_landscan_raster)
```

```{r}
plot(bimep_landscan_raster)
```

```{r write_landscan_bimep}
names(bimep_landscan_raster) <- c("HRSL")
names(landscan) <- c("LandScan")
bls_layers <- raster::addLayer(landscan, bimep_landscan_raster)
raster::writeRaster(bls_layers, filename = fs::path(data_dir, "landscan_bimep"), format = "GTiff")
```

# BIMEP Data on WorldPop Raster

The WorldPop pixel size is 100m, so it's (0.0008333,-0.0008333)
in lat-long.

```{r worlpop_raster}
worldpop <- raster::raster(fs::path(data_dir, "Equatorial_Guinea_100m_Population", "GNQ15v2.tif"))
worldpop <- raster::crop(worldpop, bimep_feature, snap = "out")
plot(worldpop)
```
Let's turn the worldpop into a 1km grid using aggregation.
```{r aggregate_worldpop}
worldpop_1km <- raster::aggregate(worldpop, fact = 10, fun = sum, expand = TRUE)
plot(worldpop_1km)
```
Now put the BIMEP on this raster.
```{r bimep_on_worldpop}
bimep_landscan_raster <- raster::rasterize(
  bimep_feature,
  worldpop_1km,
  field = "pop",
  fun = sum
  )
names(bimep_landscan_raster)
```

```{r}
plot(bimep_landscan_raster)
```



# Look at the Incoming Data

There are over 330,000 people on Bioko island.
```{r count_mis}
if (!"mis04" %in% ls()) {
  load(fs::path(data_dir, "source", "pfpr_pops.RData"))
}
mis_vars <- ls()[(function(x) startsWith(x, "mis"))(ls())]
total_mis_rows <- sum(sapply(mis_vars, function(v) nrow(get(v))))
```
There are `r mis_total_rows` rows in the input MIS datasets.
These seem to be individual people, so that isn't all of the data.
