---
title: "Get Data"
output:
  pdf_document: default
  html_document:
    df_print: paged
cache: yes
---

```{r knitr_options, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(popbioko)
library(rprojroot)
library(sp)
library(sf)
library(tmap)
library(GISTools)
```

# Overview
This notebook retrieves input data and converts it into
gridded data about population density. This notebook should retrieve
and clean data so that we can pass that to another notebook to do statistics.
The gold standard dataset is BIMEP, so we will re-grid the BIMEP data
onto the same grids as the other datasets.

The output is all GeoTIFFs with names of the form data-on-grid.
The data are BIMEP, WorldPop, HRSL, and LandScan. The grids
are

- area, a 1km grid used by BIMEP.
- worldpop, a 100m grid used by WorldPop
- 1kworldpop, a 1km grid that aggregates and aligns with the WorldPop grid.
- landscan, the 1km LandScan grid
- hrsl, the 100m HRSL grid.

We have to take care with borders. All datasets are counts
of people in a pixel. On borders with the water, these counts
will be low, even if the density of people on land is high.
We shouldn't calculate people per square meter of habitable land.

The size of each GeoTIFF will differ between LandScan, HRSL,
and WorldPop, but each has a matched BIMEP dataset.
Pixels in the water should be marked as NA and excluded from
calculations later.

All work will use pixels in latitude and longitude (lat-long). This
is also known as an unprojected space. We'll need to
transform the BIMEP projection to lat-long, but the rest
are already in lat-long, and the BIMEP coarse and fine grids
are rectilinear in lat-long.

We will ensure each dataset has NA values where it's ocean
and 0 values inland of the ocean.

We could also rescale populations according to the growth rate
for Bioko. A commonly-used adjustment is to
multiply values by $exp(rt)$, where $r$ is the yearly growth rate.
This wouldn't affect the structure of zeroes, though.


# Get Datasets
Specify a directory into which to put the data.
The `inst/extdata` subdirectory is a popular place.
```{r data_dir}
data_dir <- fs::path(rprojroot::find_root(rprojroot::is_rstudio_project), "inst", "extdata")
if (!dir.exists(data_dir)) {
  dir.create(data_dir, recursive = TRUE)
}
```
The data will be stored in `$r data_dir$`.

```{r predefinitions}
lat_long_proj <- "+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs"
bioko_sf <- sf::st_read(fs::path(data_dir, "source", "bioko.shp"))
```


If you have an account at IHME, the following will copy files to
your local drive, under the data directory. Look at the
help for `data_configuration` to see about creating a config file
for the download.
```{r download, results = "hide"}
download_worldpop(local_directory = data_dir)
download_bioko_grids(local_directory = data_dir)
download_hrsl_points(local_directory = data_dir)
```
# Load BIMEP Early

The BIMEP data will have a "pop" feature for the population in the pixel.
Load it now so that we have its bounding box.

```{r bimep_raster}
bimep_feature <- bimep_population_as_points(local_directory = data_dir)
names(bimep_feature)
```
We see the population as `pop` and the other column, which is the geometry
for each point.

# Align HRSL and BIMEP to BIMEP 1k Grid
The Bioko grids define cells where BIMEP assigns residents of
the island. One is a 1 km grid, the other a 100 m grid.
If we read those grids, we can see that the input files
are projected into UTM 32N, which makes all distances in meters.
That's very convenient, but the original grids were defined as
a regular grid in latitude and longitude.
```{r grids, dependson = c("data_dir", "download")}
grids <- read_bioko_grids(local_directory = data_dir)
grid_info <- parameters_of_km_grid(grids$coarse, unproject = TRUE)
```
You can see from the description above that the coarse
and fine grids are shapefiles. Are these grids complete, or are they partial?
```{r complete_grids}
area_per_pixel <- function(grid) {
  bbox <- st_bbox(grid)
  (bbox["xmax"] - bbox["xmin"]) * (bbox["ymax"] - bbox["ymin"])
}
cat("area per pixel coarse", area_per_pixel(grids$coarse) / 3894, "\n")
cat("area per pixel fine", area_per_pixel(grids$fine) / 197086, "\n")
```
We see that the area per pixel for the coarse is about $10^6\:\mbox{m}^2$, which
means it's probably a complete grid. The fine grid looks far from complete
because we expect $10^4\:\mbox{m}^2$ per pixel.

If we want to make such a grid, we could use
```{r grid_copy, dpeendson = c("download")}
coarse_grid_copy <- make_fresh_grid(grid_info$bbox, grid_info$dimensions)
```
We can show the original and copy in unprojected space
in order to see that they overlap.
```{r compare_1km_grids, fig.cap = "The original and our copy overlap.", dependson = "grid_copy"}
grid_1km <- sf::st_transform(grids$coarse, crs = lat_long_proj)
tm_shape(coarse_grid_copy) +
  tm_polygons(alpha = 0.1, border.col = "red") +
  tm_shape(grid_1km) +
  tm_polygons(alpha = 0.0, border.col = "blue")
```


What if we directly make a raster version of the 1km grid?
```{r make_raster}
km_raster <- raster::raster(
  ncol = grid_info$dimensions[1],
  nrow = grid_info$dimensions[2],
  xmn = grid_info$bbox["xmin"],
  xmx = grid_info$bbox["xmax"],
  ymn = grid_info$bbox["ymin"],
  ymx = grid_info$bbox["ymax"]
  )
raster::projection(km_raster) <- lat_long_proj
```

Let's get some points to project to that raster.
The HRSL gives the location of a roof, or NA values. It doesn't say where
there could be population but isn't. Other population maps assign
a population of 0 to all non-ocean areas, including lakes. LandScan says
it extends the land area by a bit, too. We will use a shapefile for
Bioko in order to assign zero values to the HRSL.
```{r hrsl_plot}
hrsl_raster <- read_hrsl(local_directory = data_dir)
hrsl_raster_crop <- raster::crop(hrsl_raster, bimep_feature, snap = "out")
hrsl_zero_mask <- raster::rasterize(bioko_sf, hrsl_raster_crop, field = 0)
hrsl_raster_zero <- raster::cover(hrsl_raster_crop, hrsl_zero_mask)
hrsl_points_sf <- hrsl_points(hrsl_raster_crop)
# hrsl_points_sf[is.na(hrsl_points_sf[[1]]), 1] <- 0
plot(hrsl_raster_zero)
```


And do the projection using a builtin function of the raster package.
```{r project_to_raster}
km_hrsl_raster <- raster::rasterize(
  hrsl_points_sf,
  km_raster,
  field = "population_gnq_2018.10.01",
  fun = sum
  )
area_zero_raster <- raster::rasterize(bioko_sf, km_hrsl_raster, field = 0)
km_hrsl_raster <- raster::cover(km_hrsl_raster, area_zero_raster)
```

```{r}
plot(km_hrsl_raster)
```

Rasterize that pop feature, summing it per pixel.
```{r}
bimep_raster <- raster::rasterize(
  bimep_feature,
  km_raster,
  field = "pop",
  fun = sum
  )
names(bimep_raster)
```
```{r}
plot(bimep_raster)
```

We will write all raster layers the same way.
```{r}
write_one <- function(layer, basename) {
  raster::writeRaster(
    layer,
    filename = fs::path(data_dir, basename),
    format = "GTiff",
    overwrite = TRUE
    )
}
```

Write these as layers to a GeoTIFF.
```{r write_hrsl_bimep}
names(km_hrsl_raster) <- c("HRSL")
names(bimep_raster) <- c("BIMEP")
write_one(km_hrsl_raster, "hrsl_on_area")
write_one(bimep_raster, "bimep_on_area")
write_one(hrsl_raster_zero, "hrsl_on_hrsl")
```


```{r, eval = FALSE}
grids$coarse["hrsl"] <- hrsl_points_sf[[1]]
tm_shape(grids$coarse[grids$coarse$hrsl > 0,]) +
  tm_polygons("hrsl", title = "HRSL", palette = "Greens", style = "log10") +
  tm_layout(legend.title.size = 1, legend.text.size = 1)
```

# Align BIMEP to LandScan Grid

The LandScan grid is an Arc/Info Binary Grid, so it's the adf type.
It uses pixel sizes of 0.008333 in both dimensions.
It's the whole world, so we will subset it.

```{r landscan}
landscan <- read_landscan(local_directory = data_dir)
landscan <- raster::crop(landscan, bimep_feature, snap = "out")
plot(landscan)
```
Now put the bimep 100m data on the LandScan raster.
```{r}
bimep_landscan_raster <- raster::rasterize(
  bimep_feature,
  landscan,
  field = "pop",
  fun = sum
  )
names(bimep_landscan_raster)
```

```{r}
plot(bimep_landscan_raster)
```

```{r write_landscan_bimep}
names(bimep_landscan_raster) <- c("HRSL")
names(landscan) <- c("LandScan")
write_one(landscan, "landscan_on_landscan")
write_one(bimep_landscan_raster, "bimep_on_landscan")
```

# BIMEP Data on WorldPop Raster

The WorldPop pixel size is 100m, so it's (0.0008333,-0.0008333)
in lat-long.

```{r worlpop_raster}
worldpop <- raster::raster(fs::path(data_dir, "Equatorial_Guinea_100m_Population", "GNQ15v2.tif"))
worldpop <- raster::crop(worldpop, bimep_feature, snap = "out")
plot(worldpop)
```
Let's turn the worldpop into a 1km grid using aggregation.
```{r aggregate_worldpop}
worldpop_1km <- raster::aggregate(worldpop, fact = 10, fun = sum, expand = TRUE)
plot(worldpop_1km)
```
Now put the BIMEP on this raster.
```{r bimep_on_worldpop}
bimep_worldpop_raster <- raster::rasterize(
  bimep_feature,
  worldpop_1km,
  field = "pop",
  fun = sum
  )
names(bimep_worldpop_raster)
```

```{r}
plot(bimep_worldpop_raster)
```

```{r}
names(worldpop_1km) <- "WorldPop"
names(bimep_worldpop_raster) <- "BIMEP"
wp_layers <- raster::addLayer(worldpop_1km, bimep_worldpop_raster)
write_one(worldpop_1km, "worldpop_on_1kworldpop")
write_one(bimep_worldpop_raster, "bimep_on_1kworldpop")
write_one(worldpop, "worldpop_on_worldpop")
```



# Look at the Incoming Data

There are over 330,000 people on Bioko island.
```{r count_mis}
if (!"mis04" %in% ls()) {
  load(fs::path(data_dir, "source", "pfpr_pops.RData"))
}
mis_vars <- ls()[(function(x) startsWith(x, "mis"))(ls())]
total_mis_rows <- sum(sapply(mis_vars, function(v) nrow(get(v))))
```
There are `r mis_total_rows` rows in the input MIS datasets.
These seem to be individual people, so that isn't all of the data.
